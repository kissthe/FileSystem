#include "FS.h"
/*
 * 修改意见：
 * 1.直接块儿分配没有问题，但是间接块儿可能会有点问题：就是说间接块儿其实就是一个装满指针的块儿，同一个文件的inode是相同的，因此不用再分配inode
 * 2.其实据我理解你那个索引块就是我们需要的间接块儿的效果。。怪我当时把那个枚举类型命名为索引块。。。我其实想表达的是“索引块儿”是指的那个block里面存放的是目录
 * 也就是说你分配索引块儿的那个功能基本上就是我们想要的分配间接块儿的效果，因此我把那个pointer_to_pointer那个数组注释掉了
 * 3.i_number号和inode数组对应的下标一样，我当时也没说清楚，我的锅
 * 4.就是如果哪里还有问题的话可以问我
 *
 */
using namespace std;

// 函数声明区
vector<int> findFreeInodes(int num_inodes);
int findFreeDataBlock();
vector<int> findFreeDataBlocks(int num_blocks);

// 文件的分配函数
int Disk::allocateBlock_File(string file_name, string* input_buffer)
{
    if( input_buffer == nullptr ){
        cout<<"pointer to input_buffer is null"<<endl;
        exit(0);
    }
    int block_id = -1;
    int length = input_buffer->length(); // 缓冲区数据长度 
    //int block_size = 256; // 单个数据块256字节
    int block_size = blockSize;

    double num_blocks = (length + block_size - 1) / block_size; // 计算需要多少个数据块
    int num_blocks_rounded = ceil(num_blocks); // 向上取整

    // 默认分配一个inode（约定一共15个指针，前12个直接索引，第13个一级间接索引，第14个二级间接索引，第15个三级间接索引）
    int num_inodes = 1;

    // 分配所需的inode
    int inode_id = findFreeInode();
    if (inode_id == -1)
    {
        cout << "没有足够的可用空闲inode。" << endl;
        return -1;
    }

    // 标记inode为已占用
    i_bitmap[inode_id] = 1;

    // 更新inode的属性
    inodes_blocks[inode_id].i_number = inode_id;
    inodes_blocks[inode_id].recycled = false;
    inodes_blocks[inode_id].file_type = FILE_TYPE;//文件类型
    inodes_blocks[inode_id].file_name = file_name;
    inodes_blocks[inode_id].file_size=length;//这个文件内容有多大在这个时候就已经确定了
    inodes_blocks[inode_id].modified_time=modify_time();
    //inodes_blocks[inode_id].file_block = 0;

//}

//---------------------分配文件内容------------------------------

    // 如果缓冲区有内容，计算文件大小准备分配
    int flag=0;//记录当前缓冲区的字符起始位置




    // 分配数据块
    int remaining_blocks = num_blocks_rounded;//数据块的个数

    int num_blocks_to_allocate = min(remaining_blocks, 12); // 最多分配12个直接块

    // 分配 num_blocks_to_allocate 个直接块
    vector<int> block_ids = findFreeDataBlocks(num_blocks_to_allocate);

    if (block_ids.size() < num_blocks_to_allocate)
    {
        cout << "没有足够的可用空闲数据块。" << endl;
        return -1;//退出该函数
    }

    for (int i = 0; i < num_blocks_to_allocate; i++)
    {
        int block_id = block_ids[i];

        // 标记数据块为已占用
        d_bitmap[block_id] = 1;

        // 更新数据块的属性
        data_blocks[block_id].occupied = true;
        data_blocks[block_id].blockType = FILE_BLOCK;
        //data_blocks[block_id].block_id = i_number;
        //data_blocks[block_id].block_size = blockSize;

        // 将文件内容从输入缓冲区复制到数据块中
        if (input_buffer != nullptr) {
            // 假设 content 是数据块的内容缓冲区
            string tmp;
            if(flag+256<input_buffer->size()){
                tmp = input_buffer->substr(flag,256);
                flag +=256;
                strcpy(data_blocks[block_id].content, tmp.c_str());
            } else{
                tmp = input_buffer->substr(flag);
                strcpy(data_blocks[block_id].content, tmp.c_str());
                //break;
            }


            //inodes_blocks[inode_id].file_size = input_buffer->size();
        }

        // 更新inode的磁盘指针，将分配的数据块的指针添加到对应的inode的磁盘指针中
        inodes_blocks[inode_id].direct_block[i] = &data_blocks[block_id];
    }

    remaining_blocks -= num_blocks_to_allocate;

    if (remaining_blocks>0&&remaining_blocks <= 32) //需要分配一个一级间接块
    {
        // 分配一个间接块
        int indirect_block_id = findFreeDataBlock();
        if (indirect_block_id == -1) {
            cout << "没有可用的空闲数据块。" << endl;
            return -1;
        }
        // 标记数据块为已占用
        d_bitmap[indirect_block_id] = 1;

        //修改间接块的信息
        data_blocks[indirect_block_id].occupied = true;
        data_blocks[indirect_block_id].blockType = INDIRECT_BLOCK; // 间接块
        data_blocks[indirect_block_id].block_id = inode_id;
        data_blocks[indirect_block_id].block_size = blockSize;

        // 将分配的间接块的指针添加到inode块信息中
        inodes_blocks[inode_id].disk_pointer.push_back(&data_blocks[indirect_block_id]);
        //分配数据块

        //计算需要几个数据块存储数据
        int num_blocks_to_allocate2 = min(remaining_blocks, 32); // 最多分配32个数据块

        // 分配 num_blocks_to_allocate2 个数据块
        vector<int> block_ids = findFreeDataBlocks(num_blocks_to_allocate2);
        if (block_ids.size() < num_blocks_to_allocate2)
        {
            cout << "没有足够的可用空闲数据块。" << endl;
            return -1;
        }

        for (int i = 0; i < num_blocks_to_allocate2; i++)
        {
            int block_id2 = block_ids[i];

            // 标记数据块为已占用
            d_bitmap[block_id2] = 1;

            // 更新数据块的属性
            data_blocks[block_id2].occupied = true;
            data_blocks[block_id2].blockType = FILE_BLOCK;
            data_blocks[block_id2].block_id = inode_id;
            data_blocks[block_id2].block_size = blockSize;

//            // 将文件内容从输入缓冲区复制到数据块中
//            if (input_buffer != nullptr) {
//                // 假设 content 是数据块的内容缓冲区
//                strcpy(data_blocks[block_id2].content, input_buffer->c_str());
//                inodes_blocks[inode_id].file_size = input_buffer->size();
//
//            }

            // 将文件内容从输入缓冲区复制到数据块中,和上面是一样的
            string tmp;
            if(flag+256<input_buffer->size()){
                tmp = input_buffer->substr(flag,256);
                flag +=256;
                strcpy(data_blocks[block_id2].content, tmp.c_str());
            } else{
                tmp = input_buffer->substr(flag);
                strcpy(data_blocks[block_id2].content, tmp.c_str());
                break;
            }
        }

        remaining_blocks = 0;
    }

    /*
     * 如果剩余需要的块儿数大于32就需要分配一个二级间接块儿
     */
    if (remaining_blocks > 32) //需要分配多个一级间接块，需要一个二级间接块来索引（模拟情况：大小不超过256k的文件）
    {
        // 分配剩余的数据块，这些数据块需要通过间接块中的指针来指向
        int num_indirect_blocks = ceil(remaining_blocks / 32.0); // 计算需要的间接块数

        // 分配一个二级间接块
        int indirect2_block_id = findFreeDataBlock();
        if (indirect2_block_id == -1) {
            cout << "没有可用的空闲数据块。" << endl;
            return -1;
        }
        // 标记数据块为已占用
        d_bitmap[indirect2_block_id] = 1;

        // 更新数据块的属性
        data_blocks[indirect2_block_id].occupied = true;
        data_blocks[indirect2_block_id].blockType = INDIRECT_BLOCK; // 二级间接块
        data_blocks[indirect2_block_id].block_id = inode_id;
        data_blocks[indirect2_block_id].block_size = blockSize;

        // 将分配的二级间接块的指针添加到对应的inode的磁盘指针中
        inodes_blocks[inode_id].disk_pointer.push_back(&data_blocks[indirect2_block_id]);

        // 分配一级间接块并将指针添加到二级间接块中
        for (int i = 0; i < num_indirect_blocks; i++)
        {
            // 分配一个间接块
            int indirect_block_id = findFreeDataBlock();
            if (indirect_block_id == -1) {
                cout << "没有可用的空闲数据块。" << endl;
                return -1;
            }
            // 标记数据块为已占用
            d_bitmap[indirect_block_id] = 1;

            // 更新数据块的属性
            data_blocks[indirect_block_id].occupied = true;
            data_blocks[indirect_block_id].blockType = INDIRECT_BLOCK; // 间接块
            data_blocks[indirect_block_id].block_id = inode_id;
            data_blocks[indirect_block_id].block_size = blockSize;

            // 将分配的一级间接块的指针添加到二级间接块中
            data_blocks[indirect2_block_id].indirect_block[i] = (&data_blocks[indirect_block_id]);
            inodes_blocks[inode_id].disk_pointer.push_back(&data_blocks[indirect_block_id]);//存放二级间接块儿的指针
        }

        for (int i = 1; i <= num_indirect_blocks; i++) // i=0 存了指向二级间接块的指针
        {
            for (int j = 0; j < min(remaining_blocks, 32); j++)
            {
                // 分配一个数据块
                int data_block_id = findFreeDataBlock();
                if (data_block_id == -1) {
                    cout << "没有可用的空闲数据块。" << endl;
                    return -1;
                }
                // 标记数据块为已占用
                d_bitmap[data_block_id] = 1;

                // 更新数据块的属性
                data_blocks[data_block_id].occupied = true;
                data_blocks[data_block_id].blockType = FILE_BLOCK;
                data_blocks[data_block_id].block_id = inode_id;
                data_blocks[data_block_id].block_size = blockSize;

//                // 将文件内容从输入缓冲区复制到数据块中
//                if (input_buffer != nullptr) {
//                    strcpy(data_blocks[data_block_id].content, input_buffer->c_str());
//                    inodes_blocks[inode_id].file_size = input_buffer->size();
//                }
                string tmp;
                if(flag+256<input_buffer->size()){
                    tmp = input_buffer->substr(flag,256);
                    flag +=256;
                    strcpy(data_blocks[data_block_id].content, tmp.c_str());
                } else{
                    tmp = input_buffer->substr(flag);
                    strcpy(data_blocks[data_block_id].content, tmp.c_str());
                    break;
                }

                // 将指向分配的数据块的指针添加到一级间接块中
                inodes_blocks[inode_id].disk_pointer[i]->indirect_block[j] = &data_blocks[data_block_id];

            }

            remaining_blocks -= 32;
        }
    }
    return inode_id;
}

/*分配函数中用到的子函数（查询空闲磁盘块）*/
//找空闲inode 的函数
int Disk::findFreeInode() {
    // 遍历inode位视图
    for (int i = 0; i < I_BMAP_NUM; i++) {
        // 如果找到一个空闲的inode
        if (!i_bitmap[i]) {
            // 返回inode的索引
            i_bitmap[i]= 1;//表示被占用
            return i;
        }
    }

    // 没有找到空闲的inode
    return -1;
}
vector<int> Disk::findFreeInodes(int num_inodes)
{
    vector<int> free_inodes;

    // 遍历inode位视图
    for (int i = 0; i < I_BMAP_NUM; i++) {
        // 如果找到一个空闲的inode
        if (!i_bitmap[i]) {
            // 将inode的索引添加到结果中
            free_inodes.push_back(i);
            i_bitmap[i]= 1;//表示被占用

            // 如果已经找到足够数量的inode，结束循环
            if (free_inodes.size() == num_inodes) {
                break;
            }
        }
    }

    // 如果没有找到足够数量的空闲inode，返回一个空的向量
    if (free_inodes.size() < num_inodes) {
        free_inodes.clear();
    }

    return free_inodes;
}

//找空闲数据块 的函数
int Disk::findFreeDataBlock()
{
    // 遍历数据块位视图
    for (int i = 0; i < D_BMAP_NUM; i++) {
        // 如果找到一个空闲的数据块
        if (!d_bitmap[i]) {
            // 返回数据块的索引
            d_bitmap[i]= 1;
            return i;
        }
    }

    // 没有找到空闲的数据块
    return -1;
}

vector<int> Disk::findFreeDataBlocks(int num_blocks)
{
    /*
     * 在位视图中寻找空余的块儿，找到足够的块儿的话就返回这些块儿的号
     */
    vector<int> free_blocks;

    // 遍历数据块位视图
    for (int i = 0; i < D_BMAP_NUM; i++) {
        // 如果找到一个空闲的数据块
        if (!d_bitmap[i]) {
            // 将数据块索引添加到空闲块列表中
            free_blocks.push_back(i);
            d_bitmap[i]= 1;//占用

            // 如果已经找到了足够的空闲块
            if (free_blocks.size() == num_blocks) {
                // 返回所有相关的数据块索引
                return free_blocks;
            }
        }
    }

    // 如果没有找到足够的空闲块，则返回一个空的列表
    return vector<int>();
}